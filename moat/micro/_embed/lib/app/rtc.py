"""
RTC access
"""

from __future__ import annotations

import sys

from moat.micro.cmd.base import BaseCmd
from moat.micro.cmd.util.part import enc_part, get_part
from moat.util.exc import ExpKeyError


class _NotGiven:
    pass


class Cmd(BaseCmd):
    """
    Subsystem to handle RTC data.

    This app serves access to the config snippet(s) stored in the system's
    RTC chip.
    """

    def __init__(self, cfg):
        if cfg.get("fake", False):
            from moat.micro.test.rtc import state  # noqa: PLC0415
        else:
            from moat.micro.rtc import state  # noqa: PLC0415
        self.st = state

        super().__init__(cfg)

    doc_r = dict(_d="read data", p="path", _r="parts")

    async def stream_r(self, msg):
        """
        Read (part of) the RTC data area.

        As data are frequently too clunky to transmit in one go, this code
        interrogates the state step-by-step.

        @p is the path. An empty path is the root.

        If the accessed item is a dict, return data consists of a dict
        (simple keys and their values) and a list (keys for complex
        values).

        Same for a list.
        """
        # This is a stream command because it returns the enc_part output
        # as multi-element return values.
        p = msg.get("p", ())
        print("*** GET", self.st.data, p, file=sys.stderr)

        try:
            res = enc_part(get_part(self.st.data, p))
            if isinstance(res, (list, tuple)):
                await msg.result(*res)
            else:
                await msg.result(res)
        except KeyError as exc:
            raise ExpKeyError(*exc.args)

    doc_w = dict(_d="write data", p="path", d="any:deletes if missing")

    async def cmd_w(self, p=(), d=_NotGiven):
        """
        Write (part of) the RTC data area.

        As data are frequently too large to transmit in one go, this code
        updates the state step-by-step.

        @p is the path. It cannot be empty. Destination dicts are
        autogenerated.

        @d is the data replacing the destination. ``NotGiven``
        deletes the setting. Not passing @d in deletes the modifier.
        """
        if not p:
            raise ValueError("NoPath")
        if d is _NotGiven:
            del self.st[p]
        else:
            self.st[p] = d

    doc_x = dict(_d="activate data")

    async def cmd_x(self):
        """
        Activate the possibly-mangled config.

        WARNING this doesn't clear other local changes.
        """
        dest = self._parent
        if self.st.update(dest.cfg) is not dest.cfg:
            raise RuntimeError("must be updated in-place")
        await dest.reload()
