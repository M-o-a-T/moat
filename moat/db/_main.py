"""
Database support.
"""

# The main code must not load any sqlalchemy code.
# sqlalchemy might not be present.

from __future__ import annotations

import sys

import asyncclick as click
from alembic import command

from moat.util import ensure_cfg, load_subgroup

from .util import alembic_cfg, database, load

ensure_cfg("moat.db")


@load_subgroup(prefix="moat.db", invoke_without_command=False)
@click.option("-v", "--verbose", is_flag=True, help="Log database commands")
@click.pass_obj
def cli(obj, verbose):
    """Database support"""
    cfg = obj.cfg.db
    cfg.verbose = verbose


@cli.command(name="init")
@click.pass_obj
def init_(obj):
    """\
    Initialize the database.
    """
    cfg = obj.cfg.db

    meta = load(cfg)
    with database(cfg) as sess, sess.begin():
        meta.create_all(sess.bind)

        acfg = alembic_cfg(obj.cfg, sess)
        command.stamp(acfg, "head")


@cli.command()
@click.pass_obj
def update(obj):
    """
    Migrate the database.
    """
    cfg = obj.cfg.db

    with database(cfg) as sess, sess.begin():
        acfg = alembic_cfg(obj.cfg, sess)

        command.upgrade(acfg, "head")


@cli.command()
@click.argument("args", nargs=-1)
@click.pass_obj
def get(obj, args):
    """
    Read data.
    """
    cfg = obj.cfg.db

    meta = load(cfg)
    with database(cfg):
        if not args:
            for t in meta.tables:
                print(t)
            return
        t = meta.tables[args[0]]

        if len(args) == 1:
            for c in t.columns:
                print(c.name)
            return

        # TODO


@cli.group
def mig():
    """\
    Database migration commands. Development only!
    """


@mig.command(name="init")
@click.pass_obj
def mig_init(obj):
    """
    Initialize the database migration.

    This should not be necessary, as the normal "init" command will do this.
    """

    cfg = obj.cfg.db

    load(cfg)
    with database(cfg) as sess, sess.begin():
        acfg = alembic_cfg(obj.cfg, sess)
        command.stamp(acfg, "head")


@mig.command(name="rev")
@click.pass_obj
@click.argument("message", nargs=-1, type=str)
def mig_rev(obj, message):
    """
    Create a new revision.
    """
    cfg = obj.cfg.db

    if not message:
        raise click.UsageError("You need to add some change text")

    load(cfg)
    with database(cfg) as sess:
        acfg = alembic_cfg(obj.cfg, sess)

        try:
            command.check(acfg)
        except Exception:
            command.revision(acfg, " ".join(message), autogenerate=True)


@mig.command(name="check")
@click.pass_obj
def mig_check(obj):
    """
    Check if a new revision is required.
    """
    from alembic.util.exc import AutogenerateDiffsDetected  # noqa: PLC0415

    cfg = obj.cfg.db

    load(cfg)
    with database(cfg) as sess:
        acfg = alembic_cfg(obj.cfg, sess)

        try:
            command.check(acfg)
        except AutogenerateDiffsDetected as exc:
            print(exc)
            sys.exit(1)


@mig.command()
@click.pass_obj
@click.argument("revision", type=str)
def to(obj, revision):
    """
    Up/downgrade the database to a specific version.
    """
    cfg = obj.cfg.db

    load(cfg)
    with database(cfg) as sess, sess.begin():
        acfg = alembic_cfg(obj.cfg, sess)

        # Up+downgrade are no-ops when used in the "wrong" direction
        # thus it's safe to just run both
        command.upgrade(acfg, revision)
        command.downgrade(acfg, revision)


@mig.command()
@click.pass_obj
def history(obj):
    """
    Show version history.
    """
    cfg = obj.cfg.db

    load(cfg)
    with database(cfg) as sess, sess.begin():
        acfg = alembic_cfg(obj.cfg, sess)

        command.history(acfg, verbose=True)


@mig.command()
@click.pass_obj
def show(obj):
    """
    Show current version.
    """
    cfg = obj.cfg.db

    load(cfg)
    with database(cfg) as sess, sess.begin():
        acfg = alembic_cfg(obj.cfg, sess)

        command.show(acfg, "current")
